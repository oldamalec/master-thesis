\chapter{Implementace}\label{implementation}

\section{Příprava kostry aplikace}

Pro instalaci základu projektu jsem vycházel z dokumentace \cite{vue-doc} a využil NPM \cite{npm}. Tím jsem získal základní kostru aplikace, kterou je možné spouštět ve vývojářském režimu (ten podporuje například hot-swapping, ale pro produkční prostředí se nehodí, neboť není rychlostně optimalizován). Nástroje pro tvorbu optimalizované verze jsou také samozřejmě dostupné - zatím ale nejsou pro mé použití potřeba.

Jelikož se zabývám aplikací středních rozměrů, je vhodné k tomuto základu přidat některé pokročilé funkcionality, které popíšu v následujících sekcích.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Router}

Jednou z prvních komponent, kterou jsem k čistému Vue.js přidal, byl oficiální Vue Router \cite{vue-router}. Jelikož Vue.js je zaměřeno na tvorbu SPA - Single Page Application, bez konfigurace routeru by se všechny obrazovky aplikace zobrazovaly pouze na URL \code{/} - pokročilý uživatel by tak nemohl zadat například adresu \code{/task/2345}, což je vhodné i při ladění chyb - tester může jednoduše poslat zprávu \emph{\uv{na této adrese je špatně dodavatel}}.

Podobně jako chceme mít hezké URL, pro uživatele, který bude aplikaci ovládat z prohlížeče (tedy ne z aplikace), je žádoucí nastavovat správné titulky stránek. K tomu sice ve Vue Routeru neexistuje nativní podpora, ale řešení je opravdu snadné - je popsáno v jednom z \emph{Issues} v repozitáři na GitHubu \cite{vue-router-title} a spočívá v doplnění titulků do meta atributů cest:

\begin{listing}[H]
\begin{minted}[linenos,frame=lines]{javascript}
{
    path: '/',
    component: Homepage,
    meta: {
        title: 'Swordfish'
    }
}
\end{minted}
\caption{Nastavování titulků stránek pomocí Vue routeru - úprava definic} \label{code:vue-router-title1}
\end{listing}

a dále úpravě samotné instance routeru:

\begin{listing}[H]
    \begin{minted}[linenos,frame=lines]{javascript}
router.beforeEach((to, from, next) => {
    document.title = to.meta.title;
    next();
})
\end{minted}
\caption{Nastavování titulků stránek pomocí Vue routeru - úprava instance routeru} \label{code:vue-router-title2}
\end{listing}

\subsection{Webpack}

Webpack \cite{webpack} je software, který zpracovává součásti webových aplikací a tvoří z nich balíčky vhodné pro webové prohlížeče. Primárně je zaměřen na Javascript, ale dokáže zpracovávat i řadu dalších formátů, přes styly v css či sass, obrázky v png, jpeg, svg či konfigurace v json, yaml a dalších.\\
Primárním důvodem, proč používat Webpack, je možnost rozdělování kódu do jednotlivých souborů. Z jiných programovacích jazyků jsme zvyklí mít oddělenou komponentu starající se o přihlašování, v dalším souboru mít podporu komunikace s externím API atp. Samotný Javascript sice samozřejmě umožňuje kód rozdělit do více souborů, avšak vše se spojuje pouze do jednoho kontextu prohlížeče, a tak může u větších projektů být matoucí, odkud se ta která závislost vlastně bere.

\paragraph{Použití loaderů} Další příležitost k použití webpacku přichází ve chvíli, kdy chceme v projektu mít kód, který není v cílovém prohlížeči podporován. Tím může být například SASS, nebo třeba i moderní syntaxe Javascriptu řídící se standardem ES6 či novějším. S pomocí Webpacku lze nastavit, aby se při zpracování některých assetů použil \emph{loader}, který například převede SASS na CSS, konstrukce ES6 na ES5 apod. \cite{webpack-ackee}.

\paragraph{Webpack ve spolupráci s Vue.js} Základní instalace Vue.js využívá automaticky Babel \cite{babel} - to je kompilátor moderních verzí JS do starších, s kterými jsou kompatibilní prohlížeče. Pokud ale chceme využít pokročilé možnosti webpacku, je potřeba vytvořit soubor \code{webpack.config.js} kam zaneseme běženou konfiguraci webpacku - tedy seznam assetů, které budou zpracovávány a jednotlivé lodery, které je mají zpracovat.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Vue-CLI}

TODO

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Proměnné prostředí}

TODO

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Sentry}

Sentry \cite{sentry} je webová služba pro sledování chyb, které v aplikaci nastanou. Při použití v produkčním prostředí může vývojář díky Sentry o chybě vědět ještě dříve, než ji uživatel nahlásí, a to včetně všech detailů, jako například jaké kroky chybě předcházely, prostředí, ve kterém k chybě došlo a mnoho dalších.\\
Integrace s Vue.js je přímo podporována, a tak je integrace se Sentry záležitostí několika řádků kódu. V ukázce kódu \ref{code:sentry-vue} je vidět třída, kterou v projektu používám.

\begin{listing}[H]
\begin{minted}[linenos,frame=lines]{javascript}
import Vue from 'vue'
import Raven from 'raven-js';
import RavenVue from 'raven-js/plugins/vue';
import Env from '@/service/Environment'

class SentryClient {

    #client = undefined;

    constructor() {
        if (Env.isProduction()) {
            // When this is enabled, there is **no console output**
            this.#client = Raven.config('<url>')
                .addPlugin(RavenVue, Vue)
                .install();
        }
    }

    captureMessage(msg, options) {
        if (Env.isProduction() && this.#client !== undefined) {
            this.#client.captureMessage(msg, options);
        }
    }
}

const Sentry = new SentryClient();

export default Sentry;
\end{minted}
\caption{Třída pro zasílání aplikačních chyb do Sentry} \label{code:sentry-vue}
\end{listing}

\paragraph{Používání \code{class} a \code{\#} v JS kódu} V ukázce kódu \ref{code:sentry-vue} je použito klíčové slovo \code{class}, což je konstrukce představena až ve standardu ECMAScript 2015 \cite{js-class} a výsledný kód se chová totožně jako třídní objekty z jiných jazyků. Dále se uvnitř třídy vyskytuje proměnná začínající symbolem \code{\#} - zde se jedná o \emph{proposed feature} \cite{js-proposed-private} do budoucí verze ECMAScript a jedná se o privátní proměnné - opět tak jak je známe z jiných jazyků.

Samotné zavedení třídy z ukázky kódu \ref{code:sentry-vue} zajistí, že veškeré chyby, které vzniknout v produkčním prostředí, jsou automaticky zaslání do Sentry včetně veškerých detailů. Občas je ale vhodné odeslat i uživatelskou zprávu, která nemusí nutně být chybová, může jít pouze o informativní zprávu. Sentry client toto umožňuje pomocí metody \code{captureMessage}, kterou výše zmíněné třída lehce obaluje. Použití v projektu je zaznamenáno v ukázce kódu \ref{code:sentry-vue-capture}.

\begin{listing}[H]
\begin{minted}[linenos,frame=lines]{javascript}
import Sentry from "@/service/Sentry";

...

Sentry.captureMessage('Your message');
\end{minted}
\caption{Zasílání vlastních zpráv do Sentry} \label{code:sentry-vue-capture}
\end{listing}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Podpora WebApp}

V kapitole \ref{technology} jsem zmiňoval, že skladník bude aplikaci používat z nativní Android aplikace, která bude obalovat WebView, a vedoucí skladu si aplikaci otevře v běžném browseru - pro obě použití by konfigurace WebApp nebyla potřeba, avšak pokud by někdo nepotřeboval čtečku čárových kódu - což je jediný důvod, proč skladníci používají jako základ nativní Android aplikaci, je možné si otevřít na mobilu běžnou stránku a použít volbu "Přidat na plochu". Tím vznikne zástupce, který zobrazuje \emph{favicon} webové stránky a po jehož otevření se opět otevře běžný webový prohlížeč.\\
Pokud je však na stránce definovaný \code{manifest.json} pro webové aplikace, může se po otevření tohoto zástupce otevřít stránka v režimu celé obrazovky, a to případně i se skrytými ovládacími prvky - vše tak vypadá, jako kdyby se jednalo o nativní aplikaci. Základní konfigurace tohoto manifestu je vidět v ukázce kódu \ref{code:webapp-manifest}.

\begin{listing}[H]
\begin{minted}[linenos,frame=lines]{json}
{
  "short_name": "Swordfish",
  "name": "Swordfish - brána do skladového systému Atlantis",
  "icons": [
    {
      "src": "favicon/swordfish-192x192.png",
      "sizes": "192x192",
      "type": "image/png"
    }
  ],
  "start_url": "/",
  "display": "fullscreen",
  "orientation": "portrait"
}
\end{minted}
\caption{Manifest pro webové aplikace} \label{code:webapp-manifest}
\end{listing}

TODO screenshot rozdílu?

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Překlady}

Novou aplikaci je dnes vhodné hned od počátku psát jako \emph{multijazyčnou} - jako základ tedy například v češtině a angličtině.\\
Pro překlady Vue.js aplikací je vhodné použít knihovnu \code{vue-i18n}\footnote{název je zkratka pro \emph{internationalization} - číslovka 18 značí počet přeskočených znaků}. \cite{vue-i18n}\\
Použití knihovny je pak obdobné jako známe z jiných jazyků. Máme definované klíče, které mohou být i vnořené (viz ukázka kódu \ref{code:i18n-def}) a ty následně používáme v šabloně (viz ukázka kódu \ref{code:i18n-use})
\begin{listing}[h]
\begin{minted}[linenos,frame=lines]{js}
{
    close: "Zavřít",
    home: "Domů",
    notFound: "Nenalezeno",
    lang: {
        change: "Switch to English",
        changeDone: "Jazyk: čeština"
    }
}
\end{minted}
\caption{Definice překladů pro i18n} \label{code:i18n-def}
\end{listing}

\begin{listing}[h]
\begin{minted}[linenos,frame=lines]{html}
<div>
    <h1>{{ $t("base.notFound") }}</h1>
    <router-link to="/">{{ $t("base.home") }}</router-link>
</div>
\end{minted}
\caption{Použití překladů v i18n} \label{code:i18n-use}
\end{listing}

Bude-li v budoucnu někdy potřeba přidat další jazyky, stačí vzít pouze definice překladů dle klíčů a přeložit vše do nového jazyku. Zde je vhodné ještě zmínit, že pouhé překládání podle klíčů je sice rychlé, ale i tak by po nasazení nového jazyka měly být překlady zkontrolovány překladatelem přímo v aplikaci, a to navíc takovým, který rozumí cílové doméně. Pokud se tak neučiní, nastává často situace, kterou vídáme u zahraničních služeb, které expandují do Česka: překlady jsou dělané buďto strojově a nebo pouze dle klíčů, a v aplikaci se pak zobrazují slova, která bychom my jako Češi nikdy v daném kontextu nepoužili.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Material design}

Nejrozšířenější grafickou knihovnou pro tvorbu webových a mobilních aplikací pro Android je bezesporu \emph{Material Design} od Googlu.\\
První knihovna, na kterou jsem narazil, byla Vue Material \cite{vue-material}. Bohužel jsem záhy zjistil, že jelikož v době psaní práce (březen 2019) je teprve v beta verzi, a nemá implementované všechny komponenty, nakonec jsem se rozhodl pro její alternativu - Vuetify.\\
Jedná se o aktivně vyvíjenou knihovnu, která již podporuje veškeré základní prvky Material Designu a stále jsou přidávány i prvky nové \cite{vuetify}.\\
Vuetify lze navíc jednoduše integrovat s již použitou knihovnou i18n.js popisovanou v předchozí sekci.
TODO rozvést

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{State management pattern}

Jako první se zde sluší říci, co to vlastně \emph{State management pattern} je. Ve Vue.js aplikaci máme typicky velké množství komponent, a ty mezi sebou často potřebují komunikovat. Pěkný příklad je například \emph{snackbar message}, někdy nazývaná také \emph{toast message} či jednoduše \emph{oznámení o provedení akce}. To je komponenta, která musí být dostupná z jakékoliv jiné komponenty systému a vždy se musí zobrazovat na stejném místě a stejně se chovat. Je tedy žádoucí zpřístupnit její \emph{stav} a to tak, aby se při změně stavu něco automaticky stalo, a aby změna stavu byla řízena jistými pravidly.

\paragraph{Vuex} Vuex \cite{vuex} je knihovna, která implementuje \emph{State management pattern} pro Vue.js. Zařizuje jednotný přístup ke stavům komponent a umožňuje jejich řízené změny. Jeho použití v aplikaci skladového systému je vidět na ukázce kódu \ref{code:vuex-snack-def}, \ref{code:vuex-snack-snack} a \ref{code:vuex-snack-use}, kde řeší zobrazování \emph{snackbar message}.

\begin{listing}[h]
\begin{minted}[linenos,frame=lines]{js}
Vue.use(Vuex);

new Vue({
    store: new Vuex.Store({
        modules: {
            snackbar: {
                state: {
                    snack: ''
                },
                mutations: {
                    setSnack (state, snack) {
                        state.snack = snack
                    }
                },
            }
        }
    });
});
\end{minted}
\caption{Vuex pro snackbar-message: definice} \label{code:vuex-snack-def}
\end{listing}

\begin{listing}[h]
\begin{minted}[linenos,frame=lines]{js}
...
export default {
    name: "Snackbar",
    data: ...
    created: function () {
        this.$store.watch(state => state.snackbar.snack, () => {
            const msg = this.$store.state.snackbar.snack;
            if (msg !== '') {
                this.show = true;
                this.text = msg;
                this.$store.commit('setSnack', '');
            }
        })
    }
}
\end{minted}
\caption{Vuex pro snackbar-message: Snackbar komponenta} \label{code:vuex-snack-snack}
\end{listing}

\begin{listing}[h]
\begin{minted}[linenos,frame=lines]{js}
// Any Vue component
...
this.$store.commit('setSnack', '<message to display>');
...
\end{minted}
\caption{Vuex pro snackbar-message: použití z jiné komponenty} \label{code:vuex-snack-use}
\end{listing}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
