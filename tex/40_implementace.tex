\chapter{Implementace}\label{implementation}

\section{Obecné součásti aplikace}

Pro instalaci základu projektu jsem vycházel z dokumentace \cite{vue-doc} a využil NPM \cite{npm}. Tím jsem získal základní kostru aplikace, kterou je možné spouštět ve vývojářském režimu (ten podporuje například \emph{hot-swapping}, ale pro produkční prostředí se nehodí, neboť není rychlostně optimalizován). Nástroje pro tvorbu optimalizované verze jsou také samozřejmě dostupné - zatím ale nejsou pro mé použití potřeba.

Jelikož se zabývám aplikací středních rozměrů, je vhodné k tomuto základu přidat některé pokročilé funkcionality, které popíšu v následujících sekcích.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Router}

Jednou z prvních komponent, kterou jsem k čistému Vue.js přidal, byl oficiální Vue Router \cite{vue-router}. Koncept routeru je dobře znám z jakékoliv jiné aplikace, která nějak pracuje s prohlížečem uživatele - mně konkrétně byl znám z PHP.\\
Rozdíl Vue.js routeru oproti tomu, který je používán třeba ve zmiňovaném PHP, spočívá v dynamičnosti celého Javascriptového frameworku: oproti standardním aplikacím, kde přesměrování na novou adresu skutečně vyvolá požadavek na server, který odpoví obsahem stránky na dané URL, zde se vše děje dynamicky přímo na klientském zařízení, obsah je vyměněn pomocí Javascriptu a hodnota adresního řádku se změní pouze \uv{pro efekt} - tj. aby uživatel věděl, kde se nachází, a aby mohl adresu zkopírovat a sdílet. Samozřejmě i zde většinou dochází k načítání dat nově otevřené stránky, ale vše je typicky asynchronní - stránka se změní ihned a teprve poté jsou do ní doplněna data. TODO diagram?\\
Lehce matoucí může u tohoto \emph{frontendového routování} být nastavování titulků stránek, tedy \code{<title>} tagů v HTML. Celá aplikace má totiž stále pouze jeden \code{<title>} zapsaný v souboru \code{index.html}, který se sám o sobě při navigaci za pomocí routeru vůbec nemění. K vyřešení tohoto problému sice ve Vue Routeru neexistuje nativní podpora, ale řešení je opravdu snadné - je popsáno v jednom z \emph{issues} v repozitáři na GitHubu \cite{vue-router-title} a spočívá v doplnění titulků do \code{meta} atributů cest:

\begin{listing}[H]
\begin{minted}[linenos,frame=lines]{javascript}
{
    path: '/',
    component: Homepage,
    meta: {
        title: 'Swordfish'
    }
}
\end{minted}
\caption{Nastavování titulků stránek pomocí Vue routeru - úprava definic} \label{code:vue-router-title1}
\end{listing}

a dále úpravě samotné instance routeru:

\begin{listing}[H]
    \begin{minted}[linenos,frame=lines]{javascript}
router.beforeEach((to, from, next) => {
    document.title = to.meta.title;
    next();
})
\end{minted}
\caption{Nastavování titulků stránek pomocí Vue routeru - úprava instance routeru} \label{code:vue-router-title2}
\end{listing}

Další úpravou routeru, kterou jsem do jisté míry realizoval po svém, je generování drobečkové navigace. Vue Router ve spojení s Vuetify nemají nativní podporu pro zjišťování rodičovských stránek, a tak jsem si lehkou úpravou a vlastní komponentou pro vykreslování \emph{Breadcrumbs} toto zautomatizoval:\\
Každá definovaná routa má nastaveného rodiče, ke kterému poskytuje \emph{getter}. Ve vykreslování drobečkové navigace se poté na aktuální routě zjišťují rekurzivně její rodiče, a včetně jejich parametrů se z nich zpětně tvoří celý strom navigace.\\
Co se na první pohled může zdát jednoduché, se zkomplikuje ve chvíli, kdy chceme mít v cestě parametrizovanou stránku.\\
Například v URL \code{/stocks/1/locations/12/update} je potřeba v definici routy nahradit všechny identifikátory jejich reálnými hodnotami, které ale naštěstí Vue Router poskytuje i během runtime. Funkce pro vytvoření jednoho odkazu, ze kterých se skládá drobečková navigace, je znázorněna v ukázce kódu \ref{code:router:buildPath} - jejími argumenty jsou definice cesty v routě a objekt s aktuálními hodnotami parametrů.

\begin{listing}[H]
    \begin{minted}[linenos,frame=lines]{javascript}
function buildPath(pathWithPlaceholders, parameters) {
    let routePath = pathWithPlaceholders.replace(/\([^/]+\)/g, '');
    const matches = routePath.match(/(:[a-zA-Z]+\/)|(:[a-zA-Z]+$)/g);
    if (matches !== null) {
        for (const match of matches) {
            const matchParam = match.replace(/\//, '').replace(/:/, '');
            routePath = routePath
                        .replace(match, parameters[matchParam] + '/');
        }
    }
    return routePath;
}
\end{minted}
\caption{Automatické generování drobečkové navigace, včetně parametrizovaných cest} \label{code:router:buildPath}
\end{listing}

\subsection{Webpack}

Webpack \cite{webpack} je software, který zpracovává součásti webových aplikací a tvoří z nich balíčky vhodné pro webové prohlížeče. Primárně je zaměřen na Javascript, ale dokáže zpracovávat i řadu dalších formátů, přes styly v css či sass, obrázky v png, jpeg, svg či konfigurace v json, yaml a dalších.\\
Primárním důvodem, proč používat Webpack, je možnost rozdělování kódu do jednotlivých souborů. Z jiných programovacích jazyků jsme zvyklí mít oddělenou komponentu starající se o přihlašování, v dalším souboru mít podporu komunikace s externím API atp. Samotný Javascript sice samozřejmě umožňuje kód rozdělit do více souborů, avšak vše se spojuje pouze do jednoho kontextu prohlížeče, a tak může u větších projektů být matoucí, odkud se ta která závislost vlastně bere.

\paragraph{Použití loaderů} Další příležitost k použití webpacku přichází ve chvíli, kdy chceme v projektu mít kód, který není v cílovém prohlížeči podporován. Tím může být například SASS, nebo třeba i moderní syntaxe Javascriptu řídící se standardem ES6 či novějším. S pomocí Webpacku lze nastavit, aby se při zpracování některých assetů použil \emph{loader}, který například převede SASS na CSS, konstrukce ES6 na ES5 apod. \cite{webpack-ackee}.

\paragraph{Webpack ve spolupráci s Vue.js} TODO vue-cli

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Vue-CLI}

TODO

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Proměnné prostředí}

TODO

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Sentry}

Sentry \cite{sentry} je webová služba pro sledování chyb, které v aplikaci nastanou. Při použití v produkčním prostředí může vývojář díky Sentry o chybě vědět ještě dříve, než ji uživatel nahlásí, a to včetně všech detailů, jako například jaké kroky chybě předcházely, prostředí, ve kterém k chybě došlo a mnoho dalších.\\
Integrace s Vue.js je přímo podporována, a tak je integrace se Sentry záležitostí několika řádků kódu. V ukázce kódu \ref{code:sentry-vue} je vidět služba, kterou v projektu používám.

\begin{listing}[H]
\begin{minted}[linenos,frame=lines]{javascript}
import Vue from "vue";
import * as SentryService from '@sentry/browser';
import * as Integrations from '@sentry/integrations';
import {Env} from "@/service/Environment";
import {Store} from "@/service/store/Store";

const Sentry = {

    enableInDev: false, // Just for quick testing

    init() {
        if (Env.isProduction() || this.enableInDev) {
            SentryService.init({
                dsn: '<url>',
                integrations: [
                    new Integrations.Vue({
                        Vue
                    }),
                ],
            });
        }
    },

    registerUser() {
        SentryService.configureScope(scope => {
            scope.setUser({
                "id": Store.getters['oauth/getUserId'],
                "fullname": Store.getters['oauth/getUserFullName']
            });
        });
    },

    captureMessage(msg, options) {
        if ((Env.isProduction() || this.enableInDev)) {
            SentryService.captureMessage(msg, options);
        }
    }
};

export {Sentry};
\end{minted}
\caption{Služba pro zasílání aplikačních chyb do Sentry} \label{code:sentry-vue}
\end{listing}

Samotné zavedení služby (spuštění metody \code{init}) z ukázky kódu \ref{code:sentry-vue}) zajistí, že veškeré chyby, které vzniknout v produkčním prostředí, jsou automaticky zaslány do Sentry, včetně veškerých detailů. Občas je ale vhodné odeslat i uživatelskou zprávu, která nemusí nutně být chybová, může jít pouze o informativní zprávu. Sentry client toto umožňuje pomocí metody \code{captureMessage}, kterou výše zmíněné služba lehce obaluje. Použití v projektu je zaznamenáno v ukázce kódu \ref{code:sentry-vue-capture}.\\
Poslední metodou, kterou tato služba nabízí, je \code{registerUser}, díky které obsahují zasílané chyby a zprávy také informace o uživateli, který byl zrovna v aplikace přihlášen. Tato metoda je zavolána vždy po přihlášení uživatele, aby se správně měnil kontext například při odhlášení a přihlášení někoho jiného.

\begin{listing}[H]
\begin{minted}[linenos,frame=lines]{javascript}
import {Sentry} from "@/service/Sentry";
...
Sentry.captureMessage('Your message');
\end{minted}
\caption{Zasílání vlastních zpráv do Sentry} \label{code:sentry-vue-capture}
\end{listing}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Podpora WebApp}

V kapitole \ref{technology} jsem zmiňoval, že skladník bude aplikaci používat z nativní Android aplikace, která bude obalovat WebView, a vedoucí skladu si aplikaci otevře v běžném browseru - pro obě použití by konfigurace WebApp nebyla potřeba, avšak pokud by někdo nepotřeboval čtečku čárových kódu - což je jediný důvod, proč skladníci používají jako základ nativní Android aplikaci, je možné si otevřít na mobilu běžnou stránku a použít volbu "Přidat na plochu". Tím vznikne zástupce, který zobrazuje \emph{favicon} webové stránky a po jehož otevření se opět otevře běžný webový prohlížeč.\\
Pokud je však na stránce definovaný \code{manifest.json} pro webové aplikace, může se po otevření tohoto zástupce otevřít stránka v režimu celé obrazovky, a to případně i se skrytými ovládacími prvky - vše tak vypadá, jako kdyby se jednalo o nativní aplikaci. Základní konfigurace tohoto manifestu je vidět v ukázce kódu \ref{code:webapp-manifest}.

\begin{listing}[H]
\begin{minted}[linenos,frame=lines]{json}
{
  "short_name": "Swordfish",
  "name": "Swordfish - brána do skladového systému Atlantis",
  "icons": [
    {
      "src": "favicon/swordfish-192x192.png",
      "sizes": "192x192",
      "type": "image/png"
    }
  ],
  "start_url": "/",
  "display": "fullscreen",
  "orientation": "portrait"
}
\end{minted}
\caption{Manifest pro webové aplikace} \label{code:webapp-manifest}
\end{listing}

TODO screenshot rozdílu?

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Překlady}

Novou aplikaci je dnes vhodné hned od počátku psát jako \emph{multijazyčnou} - jako základ tedy například v češtině a angličtině.\\
Pro překlady Vue.js aplikací je vhodné použít knihovnu \code{vue-i18n}\footnote{název je zkratka pro \emph{internationalization} - číslovka 18 značí počet přeskočených znaků}. \cite{vue-i18n}\\
Použití knihovny je pak obdobné jako známe z jiných jazyků. Máme definované klíče, které mohou být i vnořené (viz ukázka kódu \ref{code:i18n-def}) a ty následně používáme v šabloně (viz ukázka kódu \ref{code:i18n-use})
\begin{listing}[h]
\begin{minted}[linenos,frame=lines]{js}
{
    close: "Zavřít",
    home: "Domů",
    notFound: "Nenalezeno",
    lang: {
        change: "Switch to English",
        changeDone: "Jazyk: čeština"
    }
}
\end{minted}
\caption{Definice překladů pro i18n} \label{code:i18n-def}
\end{listing}

\begin{listing}[h]
\begin{minted}[linenos,frame=lines]{html}
<div
>    <h1>{{ $t("base.notFound") }}</h1>
    <router-link to="/">{{ $t("base.home") }}</router-link>
</div>
\end{minted}
\caption{Použití překladů v i18n} \label{code:i18n-use}
\end{listing}

Bude-li v budoucnu někdy potřeba přidat další jazyky, stačí vzít pouze definice překladů dle klíčů a přeložit vše do nového jazyku. Zde je vhodné ještě zmínit, že pouhé překládání podle klíčů je sice rychlé, ale i tak by po nasazení nového jazyka měly být překlady zkontrolovány překladatelem přímo v aplikaci, a to navíc takovým, který rozumí cílové doméně. Pokud se tak neučiní, nastává často situace, kterou vídáme u zahraničních služeb, které expandují do Česka: překlady jsou dělané buďto strojově a nebo pouze dle klíčů, a v aplikaci se pak zobrazují slova, která bychom my jako Češi nikdy v daném kontextu nepoužili.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Material design}

Nejrozšířenější grafickou knihovnou pro tvorbu webových a mobilních aplikací pro Android je bezesporu \emph{Material Design} od Googlu.\\
První knihovna, na kterou jsem narazil, byla Vue Material \cite{vue-material}. Bohužel jsem záhy zjistil, že jelikož v době psaní práce (březen 2019) je teprve v beta verzi, a nemá implementované všechny komponenty, nakonec jsem se rozhodl pro její alternativu - Vuetify.\\
Jedná se o aktivně vyvíjenou knihovnu, která již podporuje veškeré základní prvky Material Designu a stále jsou přidávány i prvky nové \cite{vuetify}.\\
Vuetify lze navíc jednoduše integrovat s již použitou knihovnou i18n.js popisovanou v předchozí sekci.
TODO rozvést

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{State management pattern}

Jako první se zde sluší říci, co to vlastně \emph{State management pattern} je. Ve Vue.js aplikaci máme typicky velké množství komponent, a ty mezi sebou často potřebují komunikovat. Pěkný příklad je například \emph{snackbar message}, někdy nazývaná také \emph{toast message} či jednoduše \emph{oznámení o provedení akce}. To je komponenta, která musí být dostupná z jakékoliv jiné komponenty systému a vždy se musí zobrazovat na stejném místě a stejně se chovat. Je tedy žádoucí zpřístupnit její \emph{stav} a to tak, aby se při změně stavu něco automaticky stalo, a aby změna stavu byla řízena jistými pravidly.

\paragraph{Vuex} Vuex \cite{vuex} je knihovna, která implementuje \emph{State management pattern} pro Vue.js. Zařizuje jednotný přístup ke stavům komponent a umožňuje jejich řízené změny. Jeho použití v aplikaci skladového systému je vidět na ukázce kódu \ref{code:vuex-snack-def}, \ref{code:vuex-snack-snack} a \ref{code:vuex-snack-use}, kde řeší zobrazování \emph{snackbar message}.

\begin{listing}[h]
\begin{minted}[linenos,frame=lines]{js}
Vue.use(Vuex);

new Vue({
    store: new Vuex.Store({
        modules: {
            snackbar: {
                state: {
                    snack: ''
                },
                mutations: {
                    setSnack (state, snack) {
                        state.snack = snack
                    }
                },
            }
        }
    });
});
\end{minted}
\caption{Vuex pro snackbar-message: definice} \label{code:vuex-snack-def}
\end{listing}

\begin{listing}[h]
\begin{minted}[linenos,frame=lines]{js}
...
export default {
    name: "Snackbar",
    data: ...
    created: function () {
        this.$store.watch(state => state.snackbar.snack, () => {
            const msg = this.$store.state.snackbar.snack;
            if (msg !== '') {
                this.show = true;
                this.text = msg;
                this.$store.commit('setSnack', '');
            }
        })
    }
}
\end{minted}
\caption{Vuex pro snackbar-message: Snackbar komponenta} \label{code:vuex-snack-snack}
\end{listing}

\begin{listing}[h]
\begin{minted}[linenos,frame=lines]{js}
this.$store.commit('setSnack', '<message to display>');
\end{minted}
\caption{Vuex pro snackbar-message: použití z jiné komponenty} \label{code:vuex-snack-use}
\end{listing}

Kód z ukázky \ref{code:vuex-snack-use} se mi ovšem v průběhu psaní aplikace přestal líbit, neboť zobrazování těchto zpráv je velmi častá operace, a jeho vyvolání není v ukázce příliš jednoduché. Proto jsem si nastudoval Mixiny ve Vue.js \cite{vue-mixins} a vytvořil mixin, který zjednodušuje zasílání zpráv do Snackbaru. Použití v komponentě je znázorněné na ukázce kódu \ref{code:snack-mixin}. Kromě tohoto použití je sice navíc potřeba v komponentě nastavit, aby importovala a používala nově vytvořený mixin, který poskytuje právě metodu \code{snack()}, avšak, to lze vše provést během programování automaticky za pomoci IDE.

\begin{listing}[h]
\begin{minted}[linenos,frame=lines]{js}
this.snack('<message to display');
\end{minted}
\caption{Použití mixinu pro zjednodušení zasílání zpráv do Snackbaru} \label{code:snack-mixin}
\end{listing}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Hlídání konektivity}

V moderních aplikacích, které veškerá data ukládají na API, je vhodné hlídat dostupnost tohoto API.\\
Prvním krokem k realizaci této funkce bylo zjistit stav připojení - tedy zda je aplikace online, nebo offline. Jako první jsem našel vlastnost prohlížeče \code{window.navigator.onLine} \cite{online}, která by přesně o tomto měla informovat a navíc poskytuje i možnosti poslouchat její změny pomocí běžných JS eventů.\\
Po hlubším prozkoumání TODO
TODO kontrola konektivity (proč nepoužívat browser properities, vlastní check, jeho náročnost na síť)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Renderování formulářů}

Ještě před tím, než jsem začal tvořit formuláře ve své diplomové práci, jsem shodou okolností potřeboval upravit několik formulářů v jiné firemní aplikaci, která funguje na podobných technologiích: backend je zcela oddělený a poskytuje REST API, frontend je poté napsán v Angularu. Při zjišťování, jak složitě se zde generují formuláře jsem ale zjistil, že pro svou práci chci rozhodně vymyslet lepší systém. Níže přikládám seznam, které věci je potřeba ve zmiňovaném projektu upravit, chce-li programátor přidat nový formulářový prvek:

\begin{enumerate}
    \item přidat atribut do modelové třídy,
    \item nakódovat HTML, které atribut vypisuje,
    \item přidat atribut do instance formuláře,
    \item nastavovat výchozí obsah formuláře při načtení existujících dat z API,
    \item nastavovat nový obsah modelu při ukládání nových dat na API,
    \item nakódovat HTML, které umožňuje atribut měnit - tj. formulářový vstup.
\end{enumerate}

Celkem se tedy jedná o šest míst, kam je potřeba nový atribut zanést. Zde je ovšem na místě upozornit, že se rozhodně nejedná o problém Angularu, a že ve Vue.js není vše automaticky jednodušší - postup, jak jsem tento počet redukoval, by měl být použitelný v jakémkoliv Javascriptovém frameworku, a s většími úpravami pravděpodobně i v jiných jazycích.\\
Co se mi zejména nelíbilo, byl fakt, že \emph{modelová třída} a \emph{instance formuláře} měly totožné atributy, tudíž se vůbec nemusí nastavovat jedna po druhé, ale můžeme použít například \code{Object.assign()} \cite{mdn-object-assign} pro nakopírování hodnot jednoho objektu do druhého. \emph{(Tato metoda sice není podporována v Android WebView, avšak napsat její ruční alternativu je triviální záležitost)}. Tím dokážeme odbourat nutnost nastavování konkrétních klíčů mezi instancí formuláře a modelovou třídou - tedy položky 4. a 5. výše uvedeného seznamu.\\
Nutnost položky č. 2 - vykreslování v HTML - jsem tušil už od začátku. Tomuto je spíše kontraproduktivní se vyhýbat, neboť typicky každý atribut chceme vypsat nějak jinak, celá stránka je nějak strukturována atp. - tuto položku jsem tedy ponechal a smířil se s tím, že se bude u formulářů vždy kódovat ručně.\\
Stále ale ještě máme nutnost nastavit atribut v modelové třídě, v instanci formuláře a formulář nějak vykreslovat - tedy na třech různých místech: dvakrát v Typescriptu a jedenkrát v HTML. Má představa o jednoduše konfigurovatelném formuláři se ubírala směrem k vytvoření pouze jednoho konfiguračního souboru, odkud by se všechny tyto 3 věci generovaly, což se mi nakonec podařilo, a seznam jsem tedy stáhl na:

\begin{enumerate}
    \item nastavit atribut v konfiguračním souboru,
    \item nakódovat HTML, které atribut vypisuje.
\end{enumerate}

Důležité je zde zdůraznit, že jsem odebral i nutnost vytvořit HTML kód formuláře: pokud po formulářovém prvku nejsou vyžadovány žádné nestandardní požadavky, jsou všechny atributy formuláře zpracovávány a vykresleny zcela automaticky pomocí komponenty, kterou jsem pro tento účel vytvořil.\\
V tuto chvíli je na místě projít ukázku kódu (\ref{code:formfields:def}), která znázorňuje, jak může vypadat \emph{definice formuláře} pro jednoduché skladové umístění:

\begin{listing}[h]
\begin{minted}[linenos,frame=lines]{js}
const stockLocationForm = {
    name: '',
    code: null
};

const stockLocationFormRender = {
    name: {
        icon: 'label',
        max: 50,
        required: true
    },
    code: {
        icon: 'line_weight',
        max: 40,
        hint: 'stocks.locations.codehint'
    }
};

export {stockLocationForm, stockLocationFormRender};
\end{minted}
\caption{Příklad definice formuláře: jednoduché skladové umístění} \label{code:formfields:def}
\end{listing}

Rozdělení na \code{Form} a \code{FormRender} je zvoleno z toho důvodu, aby se oddělily logické celky: model (\code{Form}) a definice zobrazení (\code{FormRender}). Model se takto může celý při uložení poslat na API a při načtení se naopak celý přepíše daty z API. Definice zobrazení pak obsahuje informace, jak má samotný formulářový prvek vypadat a chovat se.\\
Takovýto konfigurační soubor se poté pouze načte v komponentě, která má formulář zobrazovat, a zde předá výše zmiňované komponentě pro standardizované vykreslování formulářů.\\
Seznam konfigurovatelných možností pro každý atribut formuláře zahrnuje například:

\begin{itemize}
    \item \emph{label:} název formulářového prvku - pokud není vyplněný, hledá se definice překladu dle názvu klíče atributu,
    \item \emph{icon:} označení ikony z Material Icons, která se bude zobrazovat vlevo od formulářového prvku,
    \item \emph{hint:} cesta k překladu hlášky, která se bude zobrazovat pod formulářovým prvkem,
    \item \emph{items:} pole s hodnotami, které budou na výběr, jedná li-se o prvek typu \code{select} nebo \code{autocomplete},
    \item \emph{loading:} booleanovská hodnota, zda má mít prvek načítací stav. Typicky se nenastavuje v konfiguračním souboru, ale může být ovládáno z komponenty, která formulář vykresluje,
    \item \emph{multiple:} booleanovská hodnota, která určuje, zda prvek typu \code{select} nebo \code{autocomplete} může mít více vybraných hodnot současně,
    \item \emph{readonly:} booleanovská hodnota určující, zda má být prvek pouze pro čtení,
    \item \emph{rules:} pole pravidel pro validaci prvku (pravidla \code{max} a \code{required} je pro zjednodušení možné zadat i napřímo v konfiguraci),
    \item \emph{createNew:} co se má zobrazit a případně stát, pokud je prvek typu \code{select} nebo \code{autocomplete} a vyhledávání přípustných prvků nenalezlo žádnou shodu na uživatelův vstup,
    \item \emph{autocomplete:} struktura obsahující metody, které se mají zavolat na API, a které následná data zpracují a automaticky tak vytvoří seznam \emph{items}, které budou nabízeny ve formulářovém prvku typu \code{autocomplete}.
\end{itemize}

Jedná se tedy o poměrně flexibilní systém, který umí nejen zpracovávat různé typy vstupů, ale také je poměrně slušně upravovat a přizpůsobovat - pro mé potřeby vykreslování především formulářů na tvorbu či úpravu entit, které se v systému nacházejí: tj. skladů, dodavatelů, produktových karet, odběratelů, umístění apod., a dále formulářů zadávání a schvalování úloh, které na skladě probíhají, je tato komponenta a její konfigurace naprosto dostačující a do budoucna hlavně velmi snadně rozšiřitelná a konfigurovatelná. Ukázka formuláře vytvořeného přes tuto jednotnou komponentu je dostupná v příloze TODO

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Realizace podpory pro undo}\label{implementation:undo}

Jak jsme s Pavlem rozhodli v návrhové části (sekce \ref{draft:undo}), undo je realizováno přímou podporou u vybraných akcí.\\
Pro demonstraci celé funkčnosti byla v první fázi vybrána \emph{správa výrobců zboží}, u které je možné procházet kompletní historii změn, a tedy i provádět undo. Základní implementace rozšiřuje běžné \emph{snack messages} přidáním tlačítka \uv{vrátit} (obrázek \ref{picture:undo}). Takovýto toast message má nastavenou zvýšenou či neomezenou životnost, nezmizí tedy během pár sekund, jako ty ostatní. Po využití funkce vrácení se po úspěšném dokončení zobrazí buďto obrázek \ref{picture:undo-after}, či případně chybová hláška.

\begin{figure}[]
\includegraphics[width=0.6\textwidth]{../png/app/undo_snack.png}
\caption{Undo: Možnost vrácení provedených změn} \label{picture:undo}
\end{figure}

\begin{figure}[]
\includegraphics[width=0.6\textwidth]{../png/app/undo_snack_after.png}
\caption{Undo: Potvrzení vrácení provedených změn} \label{picture:undo-after}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


TODO popsat nový vue.config.js a vue ui - dashboard, deps, analyzet atp.

TODO JS Flow

TODO Renderer formulářů

TODO text filtry

https://itnext.io/yes-this-is-how-to-cache-pages-by-url-with-vue-vue-router-and-keep-alive-component-697ed76896e8

TODO kontextové menu

TODO exporty co CSV a JS

TODO renderer tabulek

TODO barvy accent a secondarz ale idempotence

TODO polyfills https://cli.vuejs.org/guide/browser-compatibility.html

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Funkční specifikace}

// TODO jednotlivé úlohy atp.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Perličky z vývoje}

\subsection{Špatně importované ikony}

Když jsem byl zhruba v polovině tvorby první použitelné verze aplikace, vyšla aktualizace knihovny \emph{Vuetify}, která z verze 1.x poskočila na verzi 2.0. To ssebou neslo poměrně hodně \emph{breaking changes} \cite{vuetify-2-upgrade}, které jsem ale postupně všechny prošel a aplikaci upravil, takže brzy opět fungovala na nové verzi Vuetify.\\
Po nějakém čase jsem si ale všiml, že u checkboxů a dalších formulářových prvků chybí některé jejich součásti - například u checkboxu to bylo hodně výrazné - tam chyběl celý zaškrtávací čtvereček a byl vidět pouze \emph{label}. Nejprve jsem problém ignoroval s tím, že se pravděpodobně jedná o chybu knihovny, a v některé z dalších verzí bude vše opraveno.\\
Když však ale ani po měsíci nebyly checkboxy stále vidět, začal jsem hledat příčinu problému. Samozřejmě jsem nejprve nahlížel do \emph{Nástrojů vývojáře} v prohlížeči, ale tam jsem nic zajímavého nezjistil - pouze to, že z nějakého důvodu se v mé aplikaci narozdíl od oficiální dokumentace Vuetify \cite{vuetify-doc-checkbox} (kde checkboxy samozřejmě fungovaly), nerenderuje kus HTML, který je má na starost. Založil jsem si tedy nový lokální projekt s Vue.js + Vuetify, kde checkboxy samozřejmě také fungovaly. Postupně jsem tedy začal odebírat různé závislosti z npm, abych přišel na to, která knihovna tento problém způsobuje. Při tomto procesu jsem rovnou zauditoval, zda opravdu potřebuji všechny dříve používané závislosti, a upravil i některé kusy kódu tak, aby závislosti již nebyly potřebné, a tedy jsem kód vlastně zefektivnil a zmenšil velikost výsledné aplikace. Stále jsem ale nemohl přijít na to, proč nefungují checkboxy.\\
Teprve asi po 6 hodinách a asi 40x přeinstalovanými všemi závislostmi, jsem se dostal k importu \emph{Material Design Icons} \cite{mdi}. Vuetify ve verzi 2.0 přidalo do možností své konfigurace klíč, který určuje, který ikonový font se má použit. Při migraci na novou verzi jsem použil ukázkové nastavení této hodnoty, tedy \uv{mdi}. V žádném případě mě totiž nenapadlo, že \emph{Material Design Icons (mdi)} a \emph{Material Icons (md)} není to samé!\\
Po chvilce dalšího ladění s importem ikonek vyšlo najevo, že nastavení \uv{mdi} není kompatibilní s načítáním ikon z CDN Googlu, ale musí se použít balíček z npm. V případě, že chcete načítat ikonky z CDN, musí být hodnota \emph{iconfont} nastavena pouze na \uv{md}. Celý problém, na kterém jsem strávil tolik hodin a nechápavých výrazů šel tedy opravit diffem z ukázky kódu \ref{code:mdi:diff}.

\begin{listing}[h]
\begin{minted}[linenos,frame=lines]{js}
-    iconfont: 'mdi',
+    iconfont: 'md',
\end{minted}
\caption{Diff nastavení fontu ikonek ve Vuetify} \label{code:mdi:diff}
\end{listing}

